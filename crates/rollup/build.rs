use sov_mock_da::MockDaSpec;
use sov_mock_zkvm::MockZkvm;
use sov_modules_api::execution_mode::Native;
use sov_modules_api::macros::config_value;
use sov_modules_api::schemars::schema_for;
use sov_modules_api::sov_universal_wallet::schema::{Schema, SchemaGenerator};
use sov_modules_api::transaction::{Transaction, UnsignedTransaction};
use std::fs::File;
use std::io::{self, Write};
use stf_starter::Runtime;
use stf_starter::RuntimeCall;

type S = sov_modules_api::default_spec::DefaultSpec<MockDaSpec, MockZkvm, MockZkvm, Native>;

fn store_schema_as_json<T: SchemaGenerator, U: SchemaGenerator, R: SchemaGenerator>(
    filename: &str,
) -> io::Result<()> {
    let mut schema =
        Schema::of_rollup_types_with_metadata::<u64, T, U, R>(&config_value!("CHAIN_ID")).unwrap();
    let schema_string = serde_json::to_string_pretty(&schema)?;
    let mut file = File::create(filename)?;
    file.write_all(schema_string.as_bytes())?;
    file.write_all(b"\n")?;

    let chain_hash = schema.chain_hash().unwrap();
    let mut chain_hash_file = File::create("../chain_hash.autogenerated.rs")?;
    write!(
        &mut chain_hash_file,
        "pub const CHAIN_HASH: [u8; 32] = {:?};",
        chain_hash
    )?;

    Ok(())
}

fn main() -> std::io::Result<()> {
    store_schema_as_json::<
        Transaction<Runtime<S>, S>,
        UnsignedTransaction<Runtime<S>, S>,
        RuntimeCall<S>,
    >("rollup-schema.json")?;

    // usage with quicktype (after removing invalid empty `NotInstantiable` enum)
    // quicktype -s schema runtime_call.json -o runtime_call.ts
    // Resulting TypeScript file will contain strong types for the runtimes call messages
    let mut runtime_call = File::create("runtime_call.json").unwrap();
    let schema = schema_for!(RuntimeCall<S>);
    let schema_str = serde_json::to_string_pretty(&schema).unwrap();
    runtime_call.write_all(schema_str.as_bytes()).unwrap();
    runtime_call.write_all(b"\n")?;

    Ok(())
}
